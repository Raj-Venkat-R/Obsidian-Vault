---
title: "LeetCode 14 ‚Äì Longest Common Prefix"
difficulty: Easy
pattern: String / Iterative Comparison
status: Solved
---

## üîπ Problem Summary
Given an array of strings `strs`, find the **longest common prefix** shared by all strings.

- If there is no common prefix, return an empty string `""`.
- The prefix must start from the **beginning** of each string.

---

## üîπ My First Thought (Initial Approach)
- Compare every character of every string with every other string.

‚ùå This quickly becomes messy and inefficient.

---

## üîπ Key Observation
- The common prefix of all strings must be a prefix of the **first string**.
- We can **progressively shrink** the prefix by comparing it with each string.
- Once the prefix becomes empty, we can stop early.

---

## üîπ Final Approach (Step-by-Step in English)

1. Assume the first string is the initial prefix.
2. For each remaining string:
   - Compare characters of the current prefix with the current string.
   - Stop comparison when characters differ.
   - Build a new prefix using matching characters only.
3. Update the prefix after each comparison.
4. If at any point the prefix becomes empty, return `""`.
5. After processing all strings, return the final prefix.

---

## üîπ Example Walkthrough

Input:  
strs = `["flower", "flow", "flight"]`

Process:
- Start with prefix = `"flower"`
- Compare with `"flow"` ‚Üí prefix becomes `"flow"`
- Compare with `"flight"` ‚Üí prefix becomes `"fl"`
- End of array reached

Final Output:
`"fl"`

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public String longestCommonPrefix(String[] strs) {
        String pref = strs[0];

        for (int i = 1; i < strs.length; i++) {
            StringBuilder temp = new StringBuilder();
            int len = Math.min(pref.length(), strs[i].length());

            for (int j = 0; j < len; j++) {
                if (pref.charAt(j) == strs[i].charAt(j)) {
                    temp.append(pref.charAt(j));
                } else {
                    break;
                }
            }

            pref = temp.toString();
            if (pref.isEmpty()) return "";
        }
        return pref;
    }
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(n √ó m)  
  where `n` = number of strings, `m` = length of the shortest string

Space Complexity:
- O(m) for temporary prefix construction

---

## üîπ Patterns Learned

- Progressive reduction technique
- Compare pairwise instead of all at once
- Early exit when result becomes empty
- String problems often reduce to prefix comparison

---

## üîπ Common Mistakes to Avoid

- Forgetting to stop early when prefix becomes empty
- Comparing characters beyond the shortest string
- Assuming prefix length stays constant
- Using nested loops over all strings unnecessarily
