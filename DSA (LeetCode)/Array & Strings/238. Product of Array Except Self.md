
**Difficulty:** Medium  
**Pattern:** Prefix & Suffix Product  
**Status:** âŒ Bug Found â†’ âœ… Corrected  

---

## ğŸ”¹ Problem Summary
Given an integer array `nums`, return an array where each index contains the product of all elements **except itself**.

Constraints:
- No division allowed
- Must run in `O(n)` time

---

## ğŸ”¹ My First Thought (Initial Approach)
- Tried to calculate prefix product in one loop.
- Then tried to apply suffix product in another loop.
- Used an extra array to store the result.

---

## ğŸ”¹ Where I Went Wrong
- Calculated the prefix product but **never stored it** in the result array.
- The result array was initialized with `0`s by default.
- During the suffix loop, I multiplied suffix values with `0`, so the array stayed all `0`s.

---

## ğŸ”¹ Key Observation
- Prefix product must be **stored at every index**, not just calculated.
- Java initializes integer arrays with `0`, so values must be explicitly set.
- Each index result = product of elements before it Ã— product of elements after it

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Create a result array of the same size as input.
2. Initialize a variable `prefix = 1`.
3. Traverse from left to right:
 - Store `prefix` in the result array at index `i`.
 - Update `prefix` by multiplying with `nums[i]`.
4. Initialize another variable `suffix = 1`.
5. Traverse from right to left:
 - Multiply the result array at index `i` with `suffix`.
 - Update `suffix` by multiplying with `nums[i]`.
6. The result array now contains the correct product except self.

---

## ğŸ”¹ Example Walkthrough

**Input:**
nums = [1, 2, 3, 4]

**After prefix pass:**
result = [1, 1, 2, 6]

**After suffix pass:**
result = [24, 12, 8, 6]

___

```java
class Solution {

Â  Â  public int[] productExceptSelf(int[] nums) {

Â  Â  Â  Â  int arr[] = new int[nums.length];

Â  Â  Â  Â  int prefix = 1;

Â  Â  Â  Â  for(int i = 0; i < nums.length; i++){

Â  Â  Â  Â  Â  Â  arr[i] = prefix;

Â  Â  Â  Â  Â  Â  prefix *= nums[i];

Â  Â  Â  Â  }

Â  Â  Â  Â  int suffix = 1;

Â  Â  Â  Â  for(int i = nums.length - 1; i >= 0; i--){

Â  Â  Â  Â  Â  Â  arr[i] *= suffix;

Â  Â  Â  Â  Â  Â  suffix *= nums[i];

Â  Â  Â  Â  }

Â  Â  Â  Â  return arr;

Â  Â  } Â 

}
```

---

## ğŸ”¹ Time & Space Complexity
- **Time Complexity:** `O(n)` â€” two linear passes.
- **Space Complexity:** `O(1)` extra space (output array not counted).

---

## ğŸ”¹ Patterns Learned
- Prefix and Suffix technique.
- Reusing output array to save space.
- Carry-forward multiplication pattern.

---

## ğŸ”¹ Common Mistakes to Avoid
- Calculating prefix but not storing it.
- Multiplying suffix values with uninitialized (zero) array.
- Updating prefix/suffix before storing values.
- Using division instead of prefixâ€“suffix logic.

---
