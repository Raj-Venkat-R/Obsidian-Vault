---
title: LeetCode 442 ‚Äì Find All Duplicates in an Array
difficulty: Medium
pattern: Array Marking / In-place Hashing
status: Solved
---

## üîπ Problem Summary
Given an integer array `nums` of length `n` where:
- each element is in the range `[1, n]`
- some elements appear **twice**
- others appear **once**

Return all elements that appear **exactly twice**.

Constraints require:
- O(n) time
- O(1) extra space (excluding output)

---

## üîπ My First Thought (Initial Approach)
Use a HashMap or frequency array to count occurrences.

‚ùå Uses extra space ‚Üí not allowed by the problem.

---

## üîπ Key Observation
- Each value maps directly to an index:  
  value `x` ‚Üí index `x - 1`
- We can use the **sign of the number** at that index to mark visitation
- Negative value = already visited

This allows **in-place marking** without extra memory.

---

## üîπ Final Approach (Step-by-Step in English)

1. Traverse the array from left to right.
2. For each element:
   - Take absolute value (because values may already be negated).
   - Map value to index: `idx = val - 1`.
3. Check `nums[idx]`:
   - If it is **negative**, the value has been seen before ‚Üí duplicate found.
   - If it is **positive**, negate it to mark as visited.
4. Add duplicates to the result list.
5. Return the list after traversal.

---

## üîπ Example Walkthrough

Input:
nums = [4,3,2,7,8,2,3,1]

Process:
- Visit 4 ‚Üí mark index 3 negative
- Visit 3 ‚Üí mark index 2 negative
- Visit 2 ‚Üí mark index 1 negative
- Visit 7 ‚Üí mark index 6 negative
- Visit 8 ‚Üí mark index 7 negative
- Visit 2 again ‚Üí index 1 already negative ‚Üí duplicate found
- Visit 3 again ‚Üí index 2 already negative ‚Üí duplicate found

Final Output:
[2, 3]

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public List<Integer> findDuplicates(int[] nums) {
        List<Integer> lst = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            int val = Math.abs(nums[i]);
            int idx = val - 1;

            if (nums[idx] < 0) {
                lst.add(val);
            } else {
                nums[idx] = -nums[idx];
            }
        }
        return lst;
    }
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(n)

Space Complexity:
- O(1) extra space (excluding output list)

---

## üîπ Patterns Learned

- Use input constraints cleverly
- Index mapping is a powerful technique
- Sign flipping can act as a visited marker
- In-place hashing avoids extra memory

---

## üîπ Common Mistakes to Avoid

- Forgetting `Math.abs()` when indexing
- Using extra HashMap unnecessarily
- Modifying the array without considering constraints
- Assuming values outside `[1, n]`
