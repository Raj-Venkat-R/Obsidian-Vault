
**Difficulty:** Medium  
**Pattern:** Three Pointers / Dutch National Flag  
**Status:** âœ… Solved 

---

## ðŸ”¹ Problem Summary
Given an array containing only `0`, `1`, and `2`, sort the array in-place so that all `0`s come first, then `1`s, then `2`s.

---

## ðŸ”¹ My First Thought (Initial Approach)
- I initially tried using one pointer and swapping elements like a normal sorting problem.
- The idea was to move smaller elements to the front.
- I thought this would work since there are only three values.

---

## ðŸ”¹ Where I Got Stuck
- One pointer was not enough to manage three different values.
- Swapping without controlling where `2`s go caused incorrect order.
- Using a `for` loop always increments the index, which skipped re-checking swapped values.

---

## ðŸ”¹ Key Observation
- The array contains only three values: `0`, `1`, and `2`.
- Each value has a fixed position:
  - `0` â†’ left side
  - `1` â†’ middle
  - `2` â†’ right side
- When swapping with the right side, the new value at the current index is unknown.

---

## ðŸ”¹ Final Approach (Step-by-Step in English)
1. Use three pointers:
   - `left` for placing `0`s
   - `right` for placing `2`s
   - `i` for scanning the array
2. Visualize the array as:
	[ 0s | 1s | unknown | 2s ]
3. While `i <= right`:
- If the current element is `0`, swap it with `left`, then move both `left` and `i`.
- If the current element is `1`, just move `i`.
- If the current element is `2`, swap it with `right`, move `right`, and re-check the same index.

---

## ðŸ”¹ Example Walkthrough
**Input:**
[2, 0, 2, 1, 1, 0]

**Process:**
- Move `2` to the right and re-check the index.
- Move `0` to the left and move forward.
- Leave `1` in the middle.
- Continue until there are no unknown elements.

**Final Output:**
[0, 0, 1, 1, 2, 2]

___

```java
class Solution {

Â  Â  public void sortColors(int[] nums) {

Â  Â  Â  Â  int left = 0;

Â  Â  Â  Â  int right = nums.length - 1;

Â  Â  Â  Â  int i = 0;

Â  Â  Â  Â  while(i <= right){

Â  Â  Â  Â  Â  Â  if(nums[i] == 0){

Â  Â  Â  Â  Â  Â  Â  Â  int temp = nums[i];

Â  Â  Â  Â  Â  Â  Â  Â  nums[i] = nums[left];

Â  Â  Â  Â  Â  Â  Â  Â  nums[left] = temp;

Â  Â  Â  Â  Â  Â  Â  Â  left++;

Â  Â  Â  Â  Â  Â  Â  Â  i++; Â  Â  Â  Â  Â 

Â  Â  Â  Â  Â  Â  } else if(nums[i] == 2){

Â  Â  Â  Â  Â  Â  Â  Â  int temp = nums[i];

Â  Â  Â  Â  Â  Â  Â  Â  nums[i] = nums[right];

Â  Â  Â  Â  Â  Â  Â  Â  nums[right] = temp;

Â  Â  Â  Â  Â  Â  Â  Â  right--;

Â  Â  Â  Â  Â  Â  } else {

Â  Â  Â  Â  Â  Â  Â  Â  i++;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  }

}
```

---

## ðŸ”¹ Time & Space Complexity
- **Time Complexity:** `O(n)` â€” single pass through the array.
- **Space Complexity:** `O(1)` â€” in-place sorting, no extra space used.

---

## ðŸ”¹ Patterns Learned
- Dutch National Flag Algorithm.
- Three-pointer technique.
- When index movement depends on conditions, `while` loops are better than `for` loops.
- Not all sorting problems require comparison-based sorting.

---

## ðŸ”¹ Common Mistakes to Avoid
- Using only one pointer for three values.
- Incrementing the index after swapping with the right pointer.
- Using a `for` loop instead of a `while` loop.
- Forgetting that swapped values must be re-checked.

