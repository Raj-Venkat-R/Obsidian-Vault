---
title: "LeetCode 154 â€“ Find Minimum in Rotated Sorted Array II"
difficulty: Hard
pattern: Binary Search (with duplicates)
status: Understood
---

## ğŸ”¹ Problem Summary
Given a rotated sorted array that **may contain duplicates**,  
find the **minimum element**.

Unlike LC 153, duplicates make binary search decisions ambiguous.

---

## ğŸ”¹ My First Thought (Initial Approach)
Scan the entire array and return the minimum.

âŒ Works, but time complexity is O(n).  
We try to optimize using binary search, knowing worst-case can still degrade.

---

## ğŸ”¹ Key Observation
With duplicates:
- `nums[mid]` can be equal to `nums[low]` or `nums[high]`
- In such cases, we **cannot decide which half is sorted**
- We must safely shrink the search space

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Initialize:
   - `low = 0`
   - `high = last index`
2. While `low < high`:
   - Calculate `mid`
3. Compare values:
   - If `nums[mid] > nums[high]`
     â†’ minimum is in the **right half**
     â†’ `low = mid + 1`
   - Else if `nums[mid] < nums[low]`
     â†’ minimum is in the **left half**
     â†’ `high = mid`
   - Else
     â†’ duplicates block decision
     â†’ safely reduce search space using `high--`
4. Loop ends when `low == high`
5. That index contains the minimum

---

## ğŸ”¹ Example Walkthrough

Input:
nums = [2,2,2,0,1,2]

Process:
- mid equals low and high â†’ cannot decide
- shrink `high`
- eventually isolate the pivot (0)

Final Output:
0

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public int findMin(int[] nums) {
        int low = 0;
        int high = nums.length - 1;

        while (low < high) {
            int mid = (low + high) / 2;

            if (nums[mid] > nums[high]) {
                // minimum is in the right half
                low = mid + 1;
            } 
            else if (nums[mid] < nums[low]) {
                // minimum is in the left half
                high = mid;
            } 
            else {
                // duplicates â†’ cannot decide
                high--;
            }
        }
        return nums[high];
    }
}
```

---

## ğŸ”¹ Time & Space Complexity

Time Complexity:
- Best / Average: O(log n)
- Worst Case (many duplicates): O(n)

Space Complexity:
- O(1)

---

## ğŸ”¹ Patterns Learned

- Duplicates break clean binary search logic
- When unsure, shrink the boundary safely
- `high--` does not lose the minimum
- This is a modified binary search, not pure

---

## ğŸ”¹ Common Mistakes to Avoid

- Forgetting duplicates cause ambiguity
- Removing `high--` condition
- Using only LC 153 logic for this problem
- Returning `nums[mid]` instead of final pointer
