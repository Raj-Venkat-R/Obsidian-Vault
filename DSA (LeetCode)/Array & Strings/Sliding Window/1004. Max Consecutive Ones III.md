---
title: "LeetCode 1004 â€“ Max Consecutive Ones III"
difficulty: Medium
pattern: Sliding Window (Variable Size)
status: Solved
---

## ğŸ”¹ Problem Summary
Given a binary array `nums` and an integer `k`, return the **maximum number of consecutive 1s**  
in the array if you can **flip at most `k` zeros**.

- The subarray must be **contiguous**
- At most `k` zeros are allowed inside the window

---

## ğŸ”¹ My First Thought (Initial Approach)
- Try all possible subarrays.
- Count how many zeros are inside each subarray.
- If zeros â‰¤ `k`, update the maximum length.

âŒ This approach works logically but is inefficient â†’ `O(nÂ²)`.

---

## ğŸ”¹ Key Observation
- The problem deals with a **continuous subarray**.
- We are allowed **at most `k` zeros** inside the window.
- Window size is **not fixed** â†’ it expands and shrinks.
- This is a **variable-size sliding window** problem.

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Initialize two pointers `left` and `right` at `0`.
2. Maintain a variable `count` to track the number of zeros in the current window.
3. Expand the window by moving `right`:
   - If `nums[right] == 0`, increment `count`.
4. If `count > k`:
   - Shrink the window from the left.
   - If `nums[left] == 0`, decrement `count`.
   - Move `left`.
5. After ensuring `count â‰¤ k`, update the maximum window length.
6. Continue until `right` reaches the end of the array.
7. Return the maximum length found.

---

## ğŸ”¹ Example Walkthrough

Input:  
nums = `[1,1,1,0,0,0,1,1,1,1,0]`  
k = `2`

Process:
- Expand window while zeros â‰¤ 2
- When zeros exceed `k`, shrink from the left
- Always maintain a valid window
- Track the largest window size

Final Output:
`6`

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public int longestOnes(int[] nums, int k) {
        int left = 0, right = 0;
        int count = 0;
        int max = 0;

        while (right < nums.length) {
            if (nums[right] == 0) {
                count++;
            }

            if (count > k) {
                if (nums[left] == 0) {
                    count--;
                }
                left++;
            }

            max = Math.max(max, right - left + 1);
            right++;
        }
        return max;
    }
}
```

---

## ğŸ”¹ Time & Space Complexity

Time Complexity:
- O(n)

Space Complexity:
- O(1)

---

## ğŸ”¹ Patterns Learned

- Variable-size Sliding Window
- Two pointers with condition-based shrinking
- Counting elements inside a window
- Longest subarray with **at most `k`** condition

---

## ğŸ”¹ Common Mistakes to Avoid

- Resetting pointers instead of shrinking the window
- Using brute force (`O(nÂ²)`)
- Forgetting to decrement zero count when shrinking
- Confusing fixed-size and variable-size sliding windows
