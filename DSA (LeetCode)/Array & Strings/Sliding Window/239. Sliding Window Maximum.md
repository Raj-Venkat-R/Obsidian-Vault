---
title: LeetCode 239 ‚Äì Sliding Window Maximum
difficulty: Hard
pattern: Sliding Window, Monotonic Deque
status: Solved
---
## üîπ Problem Summary
Given an integer array `nums` and an integer `k`, return an array of the **maximum value in each sliding window of size `k`** as the window moves from left to right.

---

## üîπ My First Thought (Initial Approach)
- For every window of size `k`, scan all `k` elements and find the maximum.
- This leads to repeated work because windows overlap.
- Time complexity becomes too large (`O(n*k)`).

---

## üîπ Key Observation
- Smaller elements before a larger element can never become the maximum again.
- We only need to track **potential maximum candidates**.
- A **monotonic decreasing deque** allows constant-time access to the maximum.

---

## üîπ Final Approach (Step-by-Step in English)
1. Use a deque that always maintains elements in decreasing order.
2. When adding a new element:
   - Remove all smaller elements from the back of the deque.
3. Add the current element to the deque.
4. If the window size exceeds `k`, move the left pointer:
   - Remove the front element if it exits the window.
5. When the window size is exactly `k`:
   - The front of the deque is the maximum for that window.
6. Store this value and continue sliding.

---

## üîπ Example Walkthrough
**Input:**  
`nums = [1,3,-1,-3,5,3,6,7], k = 3`

**Process:**  
- Window `[1,3,-1]` ‚Üí max = `3`  
- Window `[3,-1,-3]` ‚Üí max = `3`  
- Window `[-1,-3,5]` ‚Üí max = `5`  
- Window `[-3,5,3]` ‚Üí max = `5`  
- Window `[5,3,6]` ‚Üí max = `6`  
- Window `[3,6,7]` ‚Üí max = `7`

**Final Output:**  
`[3,3,5,5,6,7]`

---

## üîπ Java Code (Final)
```java
class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int res[] = new int[nums.length + 1 - k];
        int pos = 0;

        Deque<Integer> queue = new ArrayDeque<>();
        int left = 0, right = 0;

        while (right < nums.length) {

            // maintain decreasing order
            while (!queue.isEmpty() && queue.peekLast() < nums[right]) {
                queue.removeLast();
            }
            queue.addLast(nums[right]);

            // shrink window if size exceeds k
            while (right - left + 1 > k) {
                if (nums[left] == queue.peekFirst()) {
                    queue.pop();
                }
                left++;
            }

            // window of size k
            if (right - left + 1 == k) {
                res[pos++] = queue.peekFirst();
            }
            right++;
        }
        return res;
    }
}
```

---

## üîπ Time & Space Complexity
- **Time Complexity:** `O(n)`  
  Each element is inserted and removed from the deque at most once.
- **Space Complexity:** `O(k)`  
  Deque stores at most `k` elements.

---

## üîπ Patterns Learned
- Sliding Window with two pointers
- Monotonic deque technique
- Removing useless elements early
- Front of deque always represents the maximum

---

## üîπ Common Mistakes to Avoid
- ‚ùå Using brute-force for each window
- ‚ùå Forgetting to remove elements leaving the window
- ‚ùå Not maintaining decreasing order in deque
- ‚ùå Off-by-one errors in window size calculation
- ‚ùå Confusing deque front/back operations
