---
title: "LeetCode 3 ‚Äì Longest Substring Without Repeating Characters"
difficulty: Medium
pattern: Sliding Window (Variable Size)
status: Solved
---

## üîπ Problem Summary
Given a string `s`, find the **length of the longest substring** without repeating characters.

- The substring must be **contiguous**
- Characters inside the substring must be **unique**

---

## üîπ My First Thought (Initial Approach)
- Try all possible substrings.
- Check if each substring has unique characters.
- Track the maximum length.

‚ùå This works logically but takes `O(n¬≤)` time, which is inefficient.

---

## üîπ Key Observation
- The problem is about a **substring (continuous)**, not subsequence.
- The window must always contain **unique characters**.
- When a duplicate character appears:
  - The window becomes invalid
  - We must **shrink it from the left**
- This is a **variable-size sliding window** problem.

---

## üîπ Final Approach (Step-by-Step in English)

1. Use two pointers `left` and `right` to represent the window.
2. Use a HashMap to store the **frequency of characters** in the window.
3. Expand the window by moving `right`:
   - Add the current character to the map.
4. If any character‚Äôs frequency becomes greater than `1`:
   - Shrink the window from the left
   - Continue shrinking until all characters are unique again.
5. Once the window is valid:
   - Update the maximum length.
6. Continue until `right` reaches the end of the string.
7. Return the maximum length found.

---

## üîπ Example Walkthrough

Input:
s = "abcabcbb"

Process:
- Window expands ‚Üí `"abc"` (valid)
- Next character causes duplicate (`a`)
- Shrink from left until duplicate is removed
- Continue expanding and shrinking

Final Output:
3

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public int lengthOfLongestSubstring(String s) {
        Map<Character, Integer> freq = new HashMap<>();
        int left = 0, right = 0, len = 0;

        while (right < s.length()) {
            char r = s.charAt(right);
            freq.put(r, freq.getOrDefault(r, 0) + 1);

            while (freq.get(r) > 1) {
                char l = s.charAt(left++);
                freq.put(l, freq.get(l) - 1);
                if (freq.get(l) == 0) {
                    freq.remove(l);
                }
            }

            len = Math.max(len, right - left + 1);
            right++;
        }
        return len;
    }
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(n)

Space Complexity:
- O(min(n, character set size))

---

## üîπ Patterns Learned

- Variable-size Sliding Window
- Frequency-based window control
- Longest substring with no duplicates
- Shrink window until condition becomes valid

---

## üîπ Common Mistakes to Avoid

- Using brute force (`O(n¬≤)`)
- Shrinking window only once (`if` instead of `while`)
- Updating answer before window becomes valid
- Confusing substring with subsequence
