---
title: "LeetCode 424 ‚Äì Longest Repeating Character Replacement"
difficulty: Medium
pattern: Sliding Window (Variable Size)
status: Solved
---

## üîπ Problem Summary
Given a string `s` consisting of uppercase English letters and an integer `k`,  
find the **length of the longest substring** that can be obtained by replacing  
**at most `k` characters** so that all characters in the substring are the **same**.

- The substring must be **contiguous**
- At most `k` replacements are allowed

---

## üîπ My First Thought (Initial Approach)
- Try all possible substrings.
- For each substring, calculate how many characters must be replaced to make it uniform.
- Track the maximum valid length.

‚ùå This approach works logically but is inefficient with `O(n¬≤)` time complexity.

---

## üîπ Key Observation
- The problem deals with a **substring (continuous)**.
- We do **not** need to decide which character to replace.
- For any window:
  
  **replacements needed = window size ‚àí frequency of the most frequent character**
- If replacements needed ‚â§ `k`, the window is valid.
- This fits a **variable-size sliding window** pattern.

---

## üîπ Final Approach (Step-by-Step in English)

1. Use two pointers `left` and `right` to represent a sliding window.
2. Use a HashMap to store the **frequency of characters** in the current window.
3. Expand the window by moving `right`:
   - Add `s[right]` to the frequency map.
   - Track the maximum frequency (`max`) in the window.
4. If  
   `(window size ‚àí max frequency) > k`  
   then the window is invalid.
5. Shrink the window from the left until it becomes valid again:
   - Decrease the frequency of `s[left]`
   - Move `left`
6. After the window becomes valid, update the maximum window length.
7. Continue until `right` reaches the end of the string.
8. Return the maximum length found.

---

## üîπ Example Walkthrough

Input:  
s = `"AABABBA"`, k = 1

Process:
- Expand window while replacements needed ‚â§ 1
- When replacements exceed `k`, shrink from the left
- Always maintain a valid window
- Track the maximum window length

Final Output:
4

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public int characterReplacement(String s, int k) {
        Map<Character, Integer> freq = new HashMap<>();
        int left = 0, right = 0, len = 0;
        int max = Integer.MIN_VALUE;

        while (right < s.length()) {
            char r = s.charAt(right);
            freq.put(r, freq.getOrDefault(r, 0) + 1);

            // update max frequency
            for (int val : freq.values()) {
                if (val > max) {
                    max = val;
                }
            }

            while ((right - left + 1) - max > k) {
                char l = s.charAt(left);
                freq.put(l, freq.get(l) - 1);
                if (freq.get(l) == 0) {
                    freq.remove(l);
                }
                left++;
            }

            len = Math.max(len, right - left + 1);
            right++;
        }
        return len;
    }
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(n √ó 26) ‚Üí effectively O(n)

Space Complexity:
- O(26) ‚Üí constant

---

## üîπ Patterns Learned

- Variable-size Sliding Window
- Frequency-based window control
- Longest substring with at most `k` replacements
- Shrink window until condition becomes valid

---

## üîπ Common Mistakes to Avoid

- Trying to decide which character to replace
- Using `if` instead of `while` for shrinking
- Forgetting the substring must be contiguous
- Shrinking the window only once when invalid
