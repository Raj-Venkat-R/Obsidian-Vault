---
title: "LeetCode 53 ‚Äì Maximum Subarray"
difficulty: Medium
pattern: Dynamic Programming / Kadane‚Äôs Algorithm
status: Solved
---

## üîπ Problem Summary
Given an integer array `nums`, find the **contiguous subarray** (containing at least one number)  
which has the **largest sum**, and return that sum.

---

## üîπ My First Thought (Initial Approach)
- Try all possible subarrays using two loops.
- Calculate the sum for each subarray.
- Track the maximum sum.

‚ùå This approach is inefficient because sums are recalculated repeatedly ‚Üí `O(n¬≤)`.

---

## üîπ Key Observation
- A **negative running sum** will reduce the sum of any future subarray.
- If continuing the current subarray is worse than starting fresh, discard it.
- At each index, we choose between:
  - extending the previous subarray
  - starting a new subarray from the current element

This greedy choice leads to **Kadane‚Äôs Algorithm**.

---

## üîπ Final Approach (Step-by-Step in English)

1. Initialize:
   - `sum` as the first element
   - `max` as the first element
2. Start iterating from the second element.
3. For each element:
   - Check whether adding it to the current sum is worse than starting fresh.
   - If worse, reset the running sum.
   - Otherwise, extend the current subarray.
4. After processing each element:
   - Update the global maximum sum.
5. Return the maximum sum after traversal.

---

## üîπ Example Walkthrough

Input:
`[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

Process:
- Start with `-2` ‚Üí max = `-2`
- `1` ‚Üí better to start fresh ‚Üí max = `1`
- `-3` ‚Üí extend ‚Üí sum = `-2`
- `4` ‚Üí start fresh ‚Üí max = `4`
- `-1` ‚Üí extend ‚Üí sum = `3`
- `2` ‚Üí extend ‚Üí sum = `5`
- `1` ‚Üí extend ‚Üí sum = `6` ‚Üí max = `6`
- `-5` ‚Üí extend ‚Üí sum = `1`
- `4` ‚Üí extend ‚Üí sum = `5`

Final Output:
`6`

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public int maxSubArray(int[] nums) {
        int right = 1;
        int max = nums[0];
        int sum = nums[0];

        while (right < nums.length) {
            if (sum + nums[right] < nums[right]) {
                sum = nums[right];
            } else {
                sum += nums[right];
            }
            max = Math.max(max, sum);
            right++;
        }
        return max;
    }
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(n)

Space Complexity:
- O(1)

---

## üîπ Patterns Learned

- Kadane‚Äôs Algorithm for maximum subarray problems
- Greedy + Dynamic Programming thinking
- Dropping negative prefixes improves future results

---

## üîπ Common Mistakes to Avoid

- Using nested loops unnecessarily
- Forgetting to update the global maximum
- Resetting sum incorrectly
- Thinking left/right pointers are required
- Mishandling all-negative arrays
