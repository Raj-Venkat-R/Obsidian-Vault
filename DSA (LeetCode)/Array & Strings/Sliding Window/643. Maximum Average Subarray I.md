---
title: "LeetCode 643 ‚Äì Maximum Average Subarray I"
difficulty: Easy
pattern: Sliding Window (Fixed Size)
status: Solved
---

## üîπ Problem Summary
Given an integer array `nums` and an integer `k`, find the **maximum average value** of any  
**contiguous subarray of length exactly `k`**.

Return the maximum average.

---

## üîπ My First Thought (Initial Approach)
- Try all possible subarrays of length `k`.
- Calculate the sum and average for each.
- Keep track of the maximum average.

‚ùå This works but is inefficient because it recalculates sums repeatedly ‚Üí `O(n √ó k)`.

---

## üîπ Key Observation
- The subarray length is **fixed (`k`)**.
- The problem involves **contiguous elements**.
- Sliding Window allows reuse of previous computations.
- Since `k` is constant:  
  **maximum average ‚áî maximum sum**

---

## üîπ Final Approach (Step-by-Step in English)

1. Calculate the sum of the **first `k` elements**.
2. Store this sum as both `currentSum` and `maxSum`.
3. Slide the window one step at a time:
   - Add the new element entering the window.
   - Remove the element leaving the window.
4. After each slide, update `maxSum` if the current sum is larger.
5. After traversal, return `maxSum / k`.

---

## üîπ Example Walkthrough

Input:  
nums = `[1, 12, -5, -6, 50, 3]`  
k = `4`

Process:
- First window `[1, 12, -5, -6]` ‚Üí sum = `2`
- Slide window:
  - `[12, -5, -6, 50]` ‚Üí sum = `51`
  - `[-5, -6, 50, 3]` ‚Üí sum = `42`
- Maximum sum = `51`

Final Output:
`51 / 4 = 12.75`

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public double findMaxAverage(int[] nums, int k) {
        int sum = 0;

        for (int i = 0; i < k; i++) {
            sum += nums[i];
        }

        int max = sum;

        for (int i = k; i < nums.length; i++) {
            sum += nums[i];
            sum -= nums[i - k];
            max = Math.max(max, sum);
        }

        return (double) max / k;
    }
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(n)

Space Complexity:
- O(1)

---

## üîπ Patterns Learned

- Fixed-size Sliding Window
- Reusing previous window calculations
- Tracking sum instead of average
- Maximum sum problems often translate to average problems

---

## üîπ Common Mistakes to Avoid

- Using nested loops (`O(n √ó k)`)
- Recomputing sum for every window
- Treating this as a variable-size window problem
- Calculating average inside the loop unnecessarily
