

**Difficulty:** Medium  
**Pattern:** Two Pointers  
**Status:** âœ… Solved  

---

## ğŸ”¹ Problem Summary
Given an integer array `nums` and an integer `target`, find three integers such that their sum is closest to the target.  
Return the **sum of the three integers**, not the difference.

---

## ğŸ”¹ My First Thought (Initial Approach)
- Try all possible triplets and calculate their sums.
- Compare each sum with the target and keep the closest one.
- This works logically but takes `O(nÂ³)` time, which causes TLE.

---

## ğŸ”¹ Key Observation
- Sorting the array allows us to use the **two-pointer technique**.
- After sorting:
  - Moving `left` increases the sum.
  - Moving `right` decreases the sum.
- We only need to minimize `|sum âˆ’ target|`.

---

## ğŸ”¹ Final Approach (Step-by-Step in English)
1. If the array length is exactly 3, return the sum directly.
2. Sort the array.
3. Initialize:
   - `dist` to store the minimum absolute difference.
   - `bestSum` to store the closest sum.
4. Fix one index `i` from `0` to `n - 3`.
5. For each fixed `i`:
   - Set `left = i + 1`
   - Set `right = n - 1`
6. While `left < right`:
   - Calculate the sum of the three numbers.
   - If the absolute difference from target is smaller, update `dist` and `bestSum`.
   - If `sum == target`, stop immediately (perfect match).
   - If `sum < target`, move `left` forward.
   - If `sum > target`, move `right` backward.
7. After all iterations, return `bestSum`.

---

## ğŸ”¹ Example Walkthrough
**Input:**  
nums = `[-1, 2, 1, -4]`  
target = `1`

**Process:**  
- Sort â†’ `[-4, -1, 1, 2]`
- Check valid triplets using two pointers
- Closest sum found is `2`

**Final Output:**  
`2`

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public int threeSumClosest(int[] nums, int target) {
        if(nums.length == 3) return nums[0] + nums[1] + nums[2];
        Arrays.sort(nums);
        int dist = Integer.MAX_VALUE;
        int bestSum = 0;

        for(int i = 0; i < nums.length - 2; i++){
            int left = i + 1;
            int right = nums.length - 1;

            while(left < right){
                int sum = nums[i] + nums[left] + nums[right];

                if(Math.abs(sum - target) < dist){
                    dist = Math.abs(sum - target);
                    bestSum = sum;
                }

                if(sum == target){
                    return sum;
                } else if(sum < target){
                    left++;
                } else {
                    right--;
                }
            }
        }
        return bestSum;
    }
}
```

___

## ğŸ”¹ Time & Space Complexity

- **Time Complexity:** `O(nÂ²)`
- **Space Complexity:** `O(1)` (excluding sorting)

---

## ğŸ”¹ Patterns Learned

- Sorted Array + Two Pointers
- Closest / Minimum Difference problems
- Fix one element + search remaining part

---

## ğŸ”¹ Common Mistakes to Avoid

- Returning distance instead of sum
- Forgetting `Math.abs`
- Missing `sum == target` case â†’ infinite loop
- Using brute force `O(nÂ³)`
- Wrong pointer movement