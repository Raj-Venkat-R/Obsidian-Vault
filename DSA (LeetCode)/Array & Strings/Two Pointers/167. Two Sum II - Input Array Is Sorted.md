
**Difficulty:** Medium 
**Pattern:** Two Pointers (Opposite Direction)  
**Status:** ‚úÖ Solved  

---

## üîπ Problem Summary
Given a **sorted array**, find two numbers such that their sum equals the target and return their **1-based indices**.

---

## üîπ My First Thought (Initial Approach)
- Use two nested loops
- Check every possible pair
- Time complexity becomes O(n¬≤) ‚Üí inefficient

---

## üîπ Key Observation
- The array is already **sorted**
- Sorted order allows controlled pointer movement:
  - Move left pointer to increase sum
  - Move right pointer to decrease sum

---

## üîπ Final Approach (Step-by-Step in English)
1. Place one pointer at the **start** and one at the **end**
2. Calculate the sum of values at both pointers
3. If sum equals target ‚Üí answer found
4. If sum is smaller than target ‚Üí move left pointer right
5. If sum is greater than target ‚Üí move right pointer left
6. Convert indices to **1-based indexing** before returning

---

## üîπ Example Walkthrough

**Input:**  
numbers = [2, 7, 11, 15]  
target = 9  

**Process:**  
- left = 0, right = 3 ‚Üí sum = 17 ‚Üí too large ‚Üí move right  
- left = 0, right = 1 ‚Üí sum = 9 ‚Üí answer found  

**Final Output:**  
[1, 2]

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code written only after fully understanding the logic.

```java
class Solution {
    public int[] twoSum(int[] numbers, int target) {
        int left = 0;
        int right = numbers.length - 1;

        while (left < right) {
            int currSum = numbers[left] + numbers[right];

            if (currSum == target) {
                return new int[] { left + 1, right + 1 };
            } else if (currSum < target) {
                left++;
            } else {
                right--;
            }
        }
        return new int[] { left + 1, right + 1 };
    }
}
```

___
## üîπ Time & Space Complexity

- **Time Complexity:** O(n)  
  - Each pointer moves at most `n` times
  - No nested loops

- **Space Complexity:** O(1)  
  - Only constant extra variables used

___

## üîπ Pattern

**Two Pointers ‚Äì Opposite Direction**

- One pointer starts at the beginning
- One pointer starts at the end
- Pointer movement depends on comparison with target
- Works best when the array is **sorted**

___

## üîπ Common Mistakes to Avoid

- Forgetting that the array is **sorted**
- Returning **0-based indices** instead of 1-based
- Moving both pointers at the same time
- Using a hash map instead of two pointers
- Adding `+1` to indices too early instead of at return time

