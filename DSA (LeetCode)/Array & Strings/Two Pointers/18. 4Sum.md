
**Difficulty:** Medium  
**Pattern:** Two Pointers  
**Status:** âœ… Solved  

---

## ğŸ”¹ Problem Summary
Given an integer array `nums` and an integer `target`, return **all unique quadruplets**
`[nums[a], nums[b], nums[c], nums[d]]` such that:

nums[a] + nums[b] + nums[c] + nums[d] == target

- All indices must be **distinct**
- Quadruplets must be **unique**
- Order of numbers inside a quadruplet does not matter

---

## ğŸ”¹ My First Thought (Initial Approach)
- Try all possible quadruplets using 4 loops.
- Check if their sum equals the target.
- This works logically but takes `O(nâ´)` time â†’ **TLE**.

---

## ğŸ”¹ Key Observation
- 4Sum is an **extension of 3Sum**
- After sorting:
  - Fix **two elements**
  - Use **two pointers** for the remaining two
- Duplicate values must be skipped carefully to avoid repeated quadruplets.
- Integer overflow is possible â†’ must use `long` for sum.

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Sort the array.
2. Fix the first index `i` from `0` to `n - 4`.
   - Skip duplicates for `i`.
3. Fix the second index `j` from `i + 1` to `n - 3`.
   - Skip duplicates for `j`.
4. Initialize two pointers:
   - `left = j + 1`
   - `right = n - 1`
5. While `left < right`:
   - Compute the sum using **long** to avoid overflow.
   - If sum equals target:
     - Store the quadruplet values.
     - Move both pointers.
     - Skip duplicates for `left` and `right`.
   - If sum < target â†’ move `left`.
   - If sum > target â†’ move `right`.
6. Continue until all valid quadruplets are found.

---

## ğŸ”¹ Example Walkthrough

**Input:**
nums = [-1,0,-5,-2,-2,-4,0,1,-2]  
target = -9

**Sorted:**
[-5, -4, -2, -2, -2, -1, 0, 0, 1]

**Valid Quadruplets:**
[-5, -4, -1, 1]  
[-5, -4, 0, 0]  
[-5, -2, -2, 0]  
[-4, -2, -2, -1]

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public List<List<Integer>> fourSum(int[] nums, int target) {
        Arrays.sort(nums);
        List<List<Integer>> res = new ArrayList<>();

        for(int i = 0; i < nums.length - 3; i++){
            if(i > 0 && nums[i] == nums[i-1]) continue;

            for(int j = i + 1; j < nums.length - 2; j++){
                if(j > i + 1 && nums[j] == nums[j-1]) continue;

                int left = j + 1;
                int right = nums.length - 1;

                while(left < right){
                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];

                    if(sum == target){
                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));
                        left++;
                        right--;

                        while(left < right && nums[left] == nums[left-1]) left++;
                        while(left < right && nums[right] == nums[right+1]) right--;
                    }
                    else if(sum < target){
                        left++;
                    }
                    else{
                        right--;
                    }
                }
            }
        }
        return res;
    }
}
```

___

## ğŸ”¹ Time & Space Complexity

- **Time Complexity:** `O(nÂ³)`
- **Space Complexity:** `O(1)` (excluding output)

---

## ğŸ”¹ Patterns Learned

- Sorted Array + Two Pointers
- Fix `k` elements â†’ reduce to `(k-2)` pointer problem
- Duplicate skipping pattern
- Overflow-safe summation

---

## ğŸ”¹ Common Mistakes to Avoid

- âŒ Using `int` for sum â†’ integer overflow
- âŒ Not sorting before two pointers
- âŒ Storing indices instead of values
- âŒ Forgetting to move both pointers after match
- âŒ Wrong duplicate skipping condition
- âŒ Using `if` instead of `while` for duplicates
