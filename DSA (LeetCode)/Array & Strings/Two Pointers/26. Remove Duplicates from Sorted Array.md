	

**Difficulty:** Easy  
**Pattern:** Two Pointers (Slow & Fast)  
**Status:** Solved ‚úÖ  

---

## üîπ Problem Summary
Given a **sorted array**, remove the duplicates **in-place** so that each element appears only once and return the **number of unique elements**.  
The relative order of elements must be preserved, and extra elements after the unique count do not matter.

---

## üîπ My First Thought (Initial Approach)
Since the array is already **sorted**, all duplicate elements will be placed **next to each other**.  
So instead of using extra space, I can compare adjacent elements and keep only the unique ones.

---

## üîπ Key Observation
- Sorted array means duplicates are adjacent
- First element is always unique
- We only move elements when a new value is found

---

## üîπ Final Approach (Step-by-Step in English)
1. Use two pointers:
   - **Slow pointer** tracks the index of the last unique element
   - **Fast pointer** scans through the array
2. Initialize the slow pointer at index `0`
3. Start the fast pointer from index `1`
4. For every element scanned:
   - If the current element is **different** from the element at the slow pointer:
     - Move the slow pointer one step forward
     - Copy the current element to the slow pointer position
5. After finishing the loop, the number of unique elements is `slow + 1`

---

## üîπ Example Walkthrough
Input: 
[1,1,2,2,3]

Process:
- First `1` is unique
- Second `1` ‚Üí duplicate ‚Üí ignore
- `2` ‚Üí new unique ‚Üí store
- Next `2` ‚Üí duplicate ‚Üí ignore
- `3` ‚Üí new unique ‚Üí store

Final valid array:
[1,2,3,...]

Returned count:
3

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        for(int i = 1; i < nums.length; i++){
            if(nums[slow] != nums[i]){
                slow++;
                nums[slow] = nums[i];
            }
        }
        return slow + 1;
    }
}
```

___
## üîπ Time & Space Complexity
- **Time Complexity:** O(n)
- **Space Complexity:** O(1)

---

## üîπ Patterns Learned
- Two Pointers (Slow & Fast)
- In-place array modification
- Leveraging sorted array property

---

## üîπ Common Mistakes to Avoid
- Using extra arrays (not allowed)
- Moving both pointers at the same time
- Forgetting to return `slow + 1`
