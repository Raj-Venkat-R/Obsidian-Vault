
**Difficulty:** Easy  
**Pattern:** Two Pointers  
**Status:** Solved ‚úÖ  

---

## üîπ Problem Summary
Given an array of integers and a value `val`, remove all occurrences of `val` **in-place**.  
Return the number of elements that are **not equal** to `val`.  
The order of elements can change, and elements beyond the returned length do not matter.

---

## üîπ My First Thought (Initial Approach)
I need to remove a specific value from the array without using extra space.  
Instead of deleting elements, I can **overwrite** the array by copying only the elements that are not equal to `val`.

---

## üîπ Key Observation
- The order of remaining elements does not matter
- Only elements **not equal to `val`** are useful
- I can reuse the same array and track where to place valid elements

---

## üîπ Final Approach (Step-by-Step in English)
1. Use two pointers:
   - **Slow pointer** to track the index where the next valid element should be placed
   - **Fast pointer** to scan through the array
2. Initialize the slow pointer to `0`
3. Traverse the array from start to end
4. For each element:
   - If it is **not equal** to `val`:
     - Copy it to the index pointed by the slow pointer
     - Increment the slow pointer
   - If it is equal to `val`, ignore it
5. After traversal, the value of the slow pointer represents the count of valid elements

---

## üîπ Example Walkthrough
Input:
nums = [3,2,2,3], val = 3

Process:
- `3` ‚Üí equals val ‚Üí ignore
- `2` ‚Üí valid ‚Üí place at index 0
- `2` ‚Üí valid ‚Üí place at index 1
- `3` ‚Üí equals val ‚Üí ignore

Final valid array:
[2,2,...]

Final Output:
2

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for(int i = 0; i < nums.length; i++){
            if(nums[i] != val){
                nums[slow] = nums[i];
                slow++;
            } else if(nums[i] == val){
                continue;
            }
        }
        return slow;
    }
}
```


___
## üîπ Time & Space Complexity
- **Time Complexity:** O(n)  
  The array is traversed exactly once.
- **Space Complexity:** O(1)  
  No extra space is used; modifications are done in-place.

---

## üîπ Patterns Learned
- Two Pointer technique (slow & fast)
- In-place array modification
- Filtering elements while traversing
- ‚ÄúCopy only valid elements‚Äù strategy

---

## üîπ Common Mistakes to Avoid
- Returning `slow + 1` instead of `slow`
- Using extra arrays when in-place is required
- Overthinking element deletion instead of overwriting
- Forgetting that order of elements does not matter
