**Difficulty:** Easy  
**Pattern:** Two Pointers  
**Status:** Solved âœ…

---

## ðŸ”¹ Problem Summary

Move all `0`s to the end of the array **in-place** while keeping the **relative order of non-zero elements**.

---

## ðŸ”¹ My First Thought (Initial Approach)

- Shift every zero to the end.
- But repeated shifting would take more time (nested loops).

---

## ðŸ”¹ Key Observation

- Order of **non-zero elements must not change**.
- We only care about placing non-zero elements correctly.
- Zeroes can be handled automatically.

---

## ðŸ”¹ Final Approach (Step-by-Step in English)

1. Take a pointer `slow` at index `0`.
2. Traverse the array using another pointer `i`.
3. If `nums[i]` is **non-zero**:
    - Swap `nums[i]` with `nums[slow]`.
    - Move `slow` forward.
4. Continue till the end of the array.
5. All non-zero elements come first, zeroes move to the end.

---

## ðŸ”¹ Example Walkthrough

**Input:**  
`[0, 1, 0, 3, 12]`

**Process:**
- `i=1` â†’ swap `1` with `nums[0]`
- `i=3` â†’ swap `3` with `nums[1]`
- `i=4` â†’ swap `12` with `nums[2]`

**Final Output:**  
`[1, 3, 12, 0, 0]`

---

## ðŸ”¹ Java Code (Final)

```java
class Solution {

Â  Â  public void moveZeroes(int[] nums) {

Â  Â  Â  Â  int slow = 0;

Â  Â  Â  Â  for(int i = 0; i < nums.length; i++){

Â  Â  Â  Â  Â  Â  if(nums[i] != 0){

Â  Â  Â  Â  Â  Â  Â  Â  int temp = nums[slow];

Â  Â  Â  Â  Â  Â  Â  Â  nums[slow] = nums[i];

Â  Â  Â  Â  Â  Â  Â  Â  nums[i] = temp;

Â  Â  Â  Â  Â  Â  Â  Â  slow++;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  }

}
```

___

## ðŸ”¹ Time & Space Complexity

- **Time:** `O(n)`
- **Space:** `O(1)` (in-place)

---

## ðŸ”¹ Patterns Learned

- Two Pointers
- In-place array modification
- Stable ordering of elements

---

## ðŸ”¹ Common Mistakes to Avoid

- Using extra array (not required)
- Shifting elements repeatedly (`O(nÂ²)`)
- Breaking order of non-zero elements