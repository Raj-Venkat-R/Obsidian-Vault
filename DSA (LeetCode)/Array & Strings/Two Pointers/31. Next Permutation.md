**Difficulty:** Medium  
**Pattern:** Two Pointers + Greedy  
**Status:** Solved

---

## ðŸ”¹ Problem Summary

Given an array of integers, rearrange it into the **next lexicographically greater permutation**.  
If such a permutation is not possible (array is the last permutation), rearrange it into the **lowest possible order** (sorted ascending).

---

## ðŸ”¹ My First Thought (Initial Approach)

- Generate all permutations and find the next one.
- This is inefficient and unnecessary.
- Observed that permutations follow a **lexicographical pattern** that can be exploited.

---

## ðŸ”¹ Key Observation

- From the right side, numbers usually form a **descending order**.
- The first place where this order breaks indicates where change is possible.
- Only a **small rearrangement** is needed to get the immediate next permutation.

---

## ðŸ”¹ Final Approach (Step-by-Step in English)

1. Traverse from the right to find the **pivot index** where the current element is smaller than the element next to it.
2. If no such pivot exists, the array is the last permutation, so **reverse the entire array**.
3. Otherwise, again traverse from the right to find the **just larger element** than the pivot value.
4. Swap the pivot with this just larger element.
5. Reverse the subarray **to the right of the pivot** to get the smallest possible suffix.

---

## ðŸ”¹ Example Walkthrough

**Input:**  
`[1, 2, 3]`

**Process:**

- Pivot found at index `1` (value `2`)
- Just larger element is `3`
- Swap â†’ `[1, 3, 2]`
- Reverse suffix â†’ already minimal

**Final Output:**  
`[1, 3, 2]`

---

## ðŸ”¹Java Code


```java
class Solution {

Â  Â  public void nextPermutation(int[] nums) {

Â  Â  Â  Â  int fast = nums.length - 1;

Â  Â  Â  Â  int pivot = -1;

Â  Â  Â  Â  int diff = Integer.MAX_VALUE;

Â  Â  Â  Â  for(int i = nums.length - 2; i >= 0; i--){

Â  Â  Â  Â  Â  Â  if(nums[i] < nums[i+1]){

Â  Â  Â  Â  Â  Â  Â  Â  pivot = i;

Â  Â  Â  Â  Â  Â  Â  Â  break;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  }

Â  Â  Â  Â  if(pivot == -1){

Â  Â  Â  Â  Â  Â  reverse(nums);

Â  Â  Â  Â  Â  Â  return;

Â  Â  Â  Â  }

Â  Â  Â  Â  int pos = -1;

Â  Â  Â  Â  while(fast > pivot){

Â  Â  Â  Â  Â  Â  int temp = nums[fast] - nums[pivot];

Â  Â  Â  Â  Â  Â  if(temp > 0 && temp < diff){

Â  Â  Â  Â  Â  Â  Â  Â  pos = fast;

Â  Â  Â  Â  Â  Â  Â  Â  diff = temp;

Â  Â  Â  Â  Â  Â  }

Â  Â  Â  Â  Â  Â  fast--;

Â  Â  Â  Â  }

Â  Â  Â  Â  int tt = nums[pos];

Â  Â  Â  Â  nums[pos] = nums[pivot];

Â  Â  Â  Â  nums[pivot] = tt;

Â  Â  Â  Â  int start = pivot + 1;

Â  Â  Â  Â  int end = nums.length - 1;

Â  Â  Â  Â  while(start < end){

Â  Â  Â  Â  Â  Â  int temp1 = nums[start];

Â  Â  Â  Â  Â  Â  nums[start] = nums[end];

Â  Â  Â  Â  Â  Â  nums[end] = temp1;

Â  Â  Â  Â  Â  Â  start++;

Â  Â  Â  Â  Â  Â  end--;

Â  Â  Â  Â  }

Â  Â  }

Â  Â  public void reverse(int[] nums){

Â  Â  Â  Â  int start = 0, end = nums.length - 1;

Â  Â  Â  Â  while(start < end){

Â  Â  Â  Â  Â  Â  int temp = nums[start];

Â  Â  Â  Â  Â  Â  nums[start] = nums[end];

Â  Â  Â  Â  Â  Â  nums[end] = temp;

Â  Â  Â  Â  Â  Â  start++;

Â  Â  Â  Â  Â  Â  end--;

Â  Â  Â  Â  }

Â  Â  }

}
```

___

## ðŸ”¹ Time & Space Complexity

- **Time Complexity:** `O(n)`  
    (single pass to find pivot, single pass to find swap element, one reverse)
- **Space Complexity:** `O(1)`  
    (in-place operations)

---

## ðŸ”¹ Patterns Learned

- Lexicographical permutation pattern
- Two-pointer traversal from the right
- Greedy choice to get the _next_ greater arrangement
- Suffix reversal to minimize changes

---

## ðŸ”¹ Common Mistakes to Avoid

- âŒ Swapping with any greater element instead of the **just larger** one
- âŒ Reversing the entire array instead of only the suffix
- âŒ Forgetting to handle the last permutation case
- âŒ Reversing starting from the pivot instead of `pivot + 1`
- âŒ Overlooking that the suffix is already in descending order