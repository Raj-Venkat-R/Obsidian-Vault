
**Difficulty:** Hard  
**Pattern:** Two Pointers (Opposite Direction + Invariants)  
**Status:** ‚úÖ Solved  

---

## üîπ Problem Summary
Given an array representing elevation heights, calculate how much **rain water can be trapped** between the bars after raining.

Water can be trapped only when there is a **taller bar on both left and right sides**.

---

## üîπ My First Thought (Initial Approach)
- For each index, find:
  - maximum height on the left
  - maximum height on the right
- Water at index = `min(maxLeft, maxRight) - height[i]`
- But doing this for every index separately is slow (O(n¬≤))

---

## üîπ Key Observation
- Water trapped depends on the **smaller boundary**
- If left boundary is smaller ‚Üí left side decides water
- If right boundary is smaller ‚Üí right side decides water
- We don‚Äôt need both sides fully at the same time

---

## üîπ Final Approach (Step-by-Step in English)

1. Place two pointers:
   - `left` at start
   - `right` at end
2. Maintain:
   - `maxLeft` = highest bar seen from left
   - `maxRight` = highest bar seen from right
3. Compare `height[left]` and `height[right]`:
   - If left is smaller:
     - If current left bar ‚â• maxLeft ‚Üí update maxLeft
     - Else ‚Üí water trapped = `maxLeft - height[left]`
     - Move left pointer
   - Else (right is smaller):
     - If current right bar ‚â• maxRight ‚Üí update maxRight
     - Else ‚Üí water trapped = `maxRight - height[right]`
     - Move right pointer
4. Continue until pointers meet
5. Accumulate total trapped water

---

## üîπ Example Walkthrough

**Input:**  
`height = [0,1,0,2]`

**Process:**  
- At index 2, left max = 1, right max = 2  
- Water trapped = `1 - 0 = 1`

**Final Output:**  
`1`

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code written only after fully understanding the logic.

```java
class Solution {
    public int trap(int[] height) {
        int left = 0;
        int right = height.length - 1;
        int maxleft = 0;
        int maxright = 0;
        int water = 0;

        while (left < right) {
            if (height[left] <= height[right]) {
                if (height[left] >= maxleft) {
                    maxleft = height[left];
                } else {
                    water += maxleft - height[left];
                }
                left++;
            } else {
                if (height[right] >= maxright) {
                    maxright = height[right];
                } else {
                    water += maxright - height[right];
                }
                right--;
            }
        }
        return water;
    }
}
```

___

## üîπ Time & Space Complexity

- **Time Complexity:** O(n)  
  - Each pointer moves at most once
  - Entire array is processed in a single pass

- **Space Complexity:** O(1)  
  - Only constant extra variables (`maxLeft`, `maxRight`, `water`)

___

## üîπ Pattern

**Two Pointers ‚Äì Opposite Direction with Invariants**

- One pointer starts from the left, one from the right
- Always process the side with the **smaller height**
- Maintain:
  - `maxLeft` ‚Üí maximum height seen from left
  - `maxRight` ‚Üí maximum height seen from right
- Water trapped depends on the **limiting boundary**

___

## üîπ Common Mistakes to Avoid

- Trying to calculate left and right maximums for every index
- Moving the taller pointer instead of the smaller one
- Forgetting to update `maxLeft` or `maxRight`
- Using nested loops instead of two pointers
- Mixing index values with height values

