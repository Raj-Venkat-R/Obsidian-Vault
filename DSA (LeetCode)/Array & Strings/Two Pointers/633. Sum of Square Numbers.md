---
title: "LeetCode 633 â€“ Sum of Square Numbers"
difficulty: Medium
pattern: Two Pointers / Math
status: Understood
---

## ğŸ”¹ Problem Summary
Given a non-negative integer `c`,  
determine whether there exist **two integers `a` and `b`** such that:

aÂ² + bÂ² = c

Return `true` if such numbers exist, otherwise `false`.

---

## ğŸ”¹ My First Thought (Initial Approach)
Try all possible values of `a` and `b` and check if the equation holds.

âŒ This brute force approach is too slow because it can take O(c) or worse.

---

## ğŸ”¹ Key Observation
- `aÂ²` and `bÂ²` grow monotonically
- If we fix one value, we can adjust the other intelligently
- This problem fits the **two pointers technique**

Also:
- The maximum possible value of `b` is `sqrt(c)`

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Initialize two pointers:
   - `left = 0`
   - `right = floor(sqrt(c))`
2. While `left <= right`:
   - Compute `sum = leftÂ² + rightÂ²`
3. Compare:
   - If `sum == c` â†’ valid pair found â†’ return `true`
   - If `sum < c` â†’ need larger value â†’ increment `left`
   - If `sum > c` â†’ need smaller value â†’ decrement `right`
4. If loop ends without finding a pair, return `false`

Use `long` to avoid integer overflow when squaring.

---

## ğŸ”¹ Example Walkthrough

Input:
c = 5

Process:
- left = 0, right = 2 â†’ 0Â² + 2Â² = 4 < 5 â†’ left++
- left = 1, right = 2 â†’ 1Â² + 2Â² = 5 â†’ found

Final Output:
true

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public boolean judgeSquareSum(int c) {
        long left = 0;
        long right = (long) Math.sqrt(c);

        while (left <= right) {
            long sum = left * left + right * right;

            if (sum == c) return true;
            if (sum < c) left++;
            else right--;
        }
        return false;
    }
}
```

---

## ğŸ”¹ Time & Space Complexity

Time Complexity:
- O(âˆšc)

Space Complexity:
- O(1)

---

## ğŸ”¹ Patterns Learned

- Two pointers work beyond arrays
- Monotonic behavior enables pointer movement
- Square calculations require overflow handling
- Math + pointers = optimized brute force

---

## ğŸ”¹ Common Mistakes to Avoid

- Using `int` instead of `long` (overflow issue)
- Setting `right = c` instead of `sqrt(c)`
- Using nested loops unnecessarily
- Forgetting `left <= right` condition
