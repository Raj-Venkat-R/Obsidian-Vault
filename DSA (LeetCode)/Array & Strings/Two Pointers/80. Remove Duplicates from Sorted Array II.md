
**Difficulty:** Medium  
**Pattern:** Two Pointers  
**Status:** Solved ‚úÖ  

---

## üîπ Problem Summary
Given a **sorted array**, remove duplicates **in-place** such that each element appears **at most twice**.  
The relative order of elements must be preserved, and extra elements beyond the allowed count do not matter.  
Return the **new length** of the array.

---

## üîπ My First Thought (Initial Approach)
Since the array is sorted, duplicates appear next to each other.  
Initially, it felt similar to LeetCode 26, but here the difference is that **two duplicates are allowed instead of one**.

---

## üîπ Key Observation
- Sorted array groups duplicates together
- The first two occurrences of any number are always valid
- The third occurrence onward must be skipped
- Instead of counting duplicates, we can compare with an element **two positions back**

---

## üîπ Final Approach (Step-by-Step in English)
1. If the array length is less than or equal to 2, return the length as is
2. Use a **slow pointer** to track the next write position
3. Initialize `slow = 2` since the first two elements are always allowed
4. Traverse the array starting from index `2`
5. For each element:
   - Compare it with the element at position `slow - 2`
   - If they are **different**, copy the current element to index `slow` and increment `slow`
   - If they are the **same**, skip the element
6. After traversal, `slow` represents the new length of the array

---

## üîπ Example Walkthrough
Input:
[0,0,1,1,1,1,2,3,3]

Process:
- `0` ‚Üí keep twice
- `1` ‚Üí keep twice, skip extra
- `2` ‚Üí keep
- `3` ‚Üí keep twice

Final valid array:
[0,0,1,1,2,3,3]

Returned length:
7

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        if (nums.length <= 2) return nums.length;

        int slow = 2;

        for (int i = 2; i < nums.length; i++) {
            if (nums[i] != nums[slow - 2]) {
                nums[slow] = nums[i];
                slow++;
            }
        }
        return slow;
    }
}
```

___

## üîπ Time & Space Complexity
- **Time Complexity:** O(n)  
  Each element is processed once.
- **Space Complexity:** O(1)  
  The array is modified in-place.

---

## üîπ Patterns Learned
- Two Pointer technique (write pointer + scan pointer)
- Using fixed offset comparison (`slow - 2`)
- Leveraging sorted array properties
- Controlled in-place overwriting

---

## üîπ Common Mistakes to Avoid
- Reusing LeetCode 26 logic (allows only one duplicate)
- Explicitly counting duplicates
- Comparing with the last element instead of two positions back
- Moving the write pointer incorrectly
- Overcomplicating with counters and nested conditions

