
**Difficulty:** Easy  
**Pattern:** Two Pointers (Backward Merge)  
**Status:** Solved âœ…  

---

## ðŸ”¹ Problem Summary
You are given two sorted arrays `nums1` and `nums2`.  
The first array `nums1` has a size of `m + n`, where the first `m` elements are valid and the remaining `n` elements are empty space.  
The second array `nums2` has `n` elements.  
The task is to merge `nums2` into `nums1` so that `nums1` becomes a single sorted array in non-decreasing order.

---

## ðŸ”¹ My First Thought (Initial Approach)
At first, it felt natural to try merging from the front and inserting elements into their correct positions.  
This approach led to thinking about shifting elements, which makes the solution complex and inefficient.

---

## ðŸ”¹ Key Observation
- Both arrays are already sorted
- Extra space exists at the **end** of `nums1`
- Writing from the front would overwrite useful values
- Merging from the **end** avoids shifting and data loss

---

## ðŸ”¹ Final Approach (Step-by-Step in English)
1. Use three pointers:
   - One at the last valid element of `nums1`
   - One at the last element of `nums2`
   - One at the last index of `nums1`
2. Compare the elements pointed to in `nums1` and `nums2`
3. Place the larger element at the current end position in `nums1`
4. Move the pointer of the array from which the element was taken
5. Move the write pointer backward
6. Repeat until all elements of `nums2` are placed into `nums1`

---

## ðŸ”¹ Example Walkthrough
Input:
nums1 = [1,2,3,0,0,0], m = 3  
nums2 = [2,5,6], n = 3

Process:
- Compare from the end and place the larger value
- Fill `nums1` from right to left using the available space

Final Output:
[1,2,2,3,5,6]

---

## ðŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1; 
        int j = n - 1;
        int k = m + n - 1;
        while(j >= 0){
            if(i >= 0 && nums1[i] > nums2[j]){
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
    }
}
```

___

## ðŸ”¹ Time & Space Complexity
- **Time Complexity:** O(m + n)  
  Each element from both arrays is processed exactly once.
- **Space Complexity:** O(1)  
  The merge is done in-place using the extra space already available in `nums1`.

---

## ðŸ”¹ Patterns Learned
- Backward Two Pointer technique
- Merging sorted arrays using extra space at the end
- Choosing the correct direction to avoid overwriting data
- Comparing from the largest elements first

---

## ðŸ”¹ Common Mistakes to Avoid
- Trying to merge from the front of the array
- Shifting elements to make space
- Sorting the entire array after merging
- Using extra arrays instead of in-place modification
- Misusing `m` and `n` as indices instead of counts

