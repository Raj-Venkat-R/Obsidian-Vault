---
title: "LeetCode 22 â€“ Generate Parentheses"
difficulty: Medium
pattern: Recursion / Backtracking
status: Understood
---

## ğŸ”¹ Problem Summary
Given `n` pairs of parentheses, generate **all possible valid combinations** of well-formed parentheses.

Valid means:
- Every opening bracket `(` has a matching closing bracket `)`
- At no point should closing brackets exceed opening brackets

---

## ğŸ”¹ My First Thought (Initial Approach)
Generate all combinations of `(` and `)` of length `2n`  
Then check which ones are valid.

âŒ This is inefficient because many invalid strings are generated and checked later.

---

## ğŸ”¹ Key Observation
Instead of generating everything and validating later,  
**we can avoid invalid strings from the start** by controlling decisions during recursion.

Two important counts are enough:
- number of opening brackets used
- number of closing brackets used

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Start with an empty string.
2. At every step, try to add:
   - an opening bracket `(` **only if** opening count < n
   - a closing bracket `)` **only if** closing count < opening count
3. Recursively continue building the string.
4. When both opening and closing counts reach `n`, the string is complete and valid.
5. Add it to the result list.
6. Backtrack and try other possible choices.

Important:
- Invalid sequences are **never created**
- So no extra validation is needed at the end

---

## ğŸ”¹ Example Walkthrough

Input:
n = 3

Process:
- Start with `""`
- Add `(` â†’ `"("`
- From `"("`, choices split into:
  - `"(("`
  - `"()"`
- Recursion continues by following only valid choices
- Every completed string has length `2n` and is guaranteed valid

Final Output:
["((()))", "(()())", "(())()", "()(())", "()()()"]

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    List<String> res;
    public List<String> generateParenthesis(int n) {
        res = new ArrayList<>();
        recur("", 0, 0, n);
        return res;
    }
    public void recur(String str, int op, int cp, int n){
        if(op == n && cp == n){
            res.add(str);
        }
        if(op < n){
            recur(str + "(", op + 1, cp, n);
        }
        if(cp < op){
            recur(str + ")", op, cp + 1, n);
        }
    }
}
```

---

## ğŸ”¹ Time & Space Complexity

Time Complexity:
- O(Catalan(n)) â†’ number of valid parentheses combinations

Space Complexity:
- O(n) recursion depth
- O(Catalan(n)) for storing results

---

## ğŸ”¹ Patterns Learned

- Use counters instead of validating strings later
- Backtracking avoids unnecessary work
- Constraints inside recursion prune invalid paths early

---

## ğŸ”¹ Common Mistakes to Avoid

- Allowing `)` when closing count > opening count
- Forgetting base condition when both counts reach `n`
- Thinking recursion generates invalid strings (it does not)
- Confusing recursion depth with string length
