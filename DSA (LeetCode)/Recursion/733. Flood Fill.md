---
title: "LeetCode 733 ‚Äì Flood Fill"
difficulty: Easy
pattern: DFS / Recursion
status: Understood
---

## üîπ Problem Summary
Given a 2D image matrix, a starting cell `(sr, sc)`, and a new color,  
change the color of the starting cell **and all connected cells having the same original color**  
(connected 4-directionally: up, down, left, right).

---

## üîπ My First Thought (Initial Approach)
Start from the given cell and:
- change its color
- then check all its neighbors
- repeat the same process

This naturally fits a **recursive DFS traversal**.

---

## üîπ Key Observation
Only cells with the **same original color as the starting cell** should be changed.

Also:
- If the original color is already equal to the new color, no work is needed
- This prevents infinite recursion

---

## üîπ Final Approach (Step-by-Step in English)

1. Store the original color of the starting cell (`pColor`).
2. If `pColor` is the same as the new color, return the image immediately.
3. Start a recursive DFS function from `(sr, sc)`.
4. In each recursive call:
   - Stop if the cell is out of bounds.
   - Check if the current cell has the original color.
5. If yes:
   - Change it to the new color.
   - Recursively visit its four neighbors (up, down, left, right).
6. Continue until all connected cells are processed.

---

## üîπ Example Walkthrough

Input:
image =  
[[1,1,1],  
 [1,1,0],  
 [1,0,1]]  

sr = 1, sc = 1, color = 2

Process:
- Original color = 1
- Start from (1,1)
- Fill all connected `1`s with `2`
- Stop recursion when boundary or different color is found

Final Output:
[[2,2,2],  
 [2,2,0],  
 [2,0,1]]

---

## üîπ Java Code (Final)
> ‚ö†Ô∏è Code added after fully understanding the logic.

```java
class Solution {
    int pColor;
    int[][] image;
    int color;
    public int[][] floodFill(int[][] image, int sr, int sc, int color) {
        this.image = image;
        this.pColor = image[sr][sc];
        this.color = color;
        if(pColor == color){
            return image;
        }

        flood(sr,sc);
        return image;
    }
    public void flood(int r, int c){
        if(r < 0 || r > image.length -1) return;
        if(c < 0 || c > image[0].length -1) return;

        if(image[r][c] == pColor){
            image[r][c] = color;
            flood(r-1,c);
            flood(r+1,c);
            flood(r,c-1);
            flood(r,c+1);
        }

    }
    
}
```

---

## üîπ Time & Space Complexity

Time Complexity:
- O(rows √ó columns) in the worst case (entire grid is filled)

Space Complexity:
- O(rows √ó columns) due to recursion stack in the worst case

---

## üîπ Patterns Learned

- Grid problems often use DFS or BFS
- Store original value before modifying the grid
- Always handle boundary conditions first
- Early return avoids infinite recursion

---

## üîπ Common Mistakes to Avoid

- Forgetting to check `pColor == newColor`
- Missing boundary checks
- Not checking cell color before recursion
- Revisiting already-filled cells
