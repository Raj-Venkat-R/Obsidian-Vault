---
title: "LeetCode 503 â€“ Next Greater Element II"
difficulty: Medium
pattern: Monotonic Stack
status: Understood
---

## ğŸ”¹ Problem Summary
Given a **circular array**, find the **next greater element** for each element.

The next greater element of a number is the **first greater number to its right**,  
wrapping around to the beginning if needed.  
If no such element exists, return `-1`.

---

## ğŸ”¹ My First Thought (Initial Approach)
For each element, scan to the right (and wrap around) to find a greater element.

âŒ This takes O(nÂ²) time and is too slow.

---

## ğŸ”¹ Key Observation
- This is a **Next Greater Element** problem
- Stack helps track **candidates that can be next greater**
- Circular array can be simulated by **looping twice**
- We only fill answers during the **first pass**

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Create a stack to maintain a **monotonic decreasing sequence**.
2. Initialize the result array with `-1`.
3. Traverse the array **from right to left**, from `2n-1` to `0`:
   - Use `i % n` to simulate circular indexing.
4. While stack is not empty and top â‰¤ current element:
   - Pop elements (they cannot be the next greater).
5. If `i < n` (real index, not duplicate round):
   - Top of stack is the next greater element.
6. Push current element into the stack.
7. Continue until traversal finishes.

---

## ğŸ”¹ Example Walkthrough

Input:
nums = [1,2,1]

Process:
- Traverse twice to simulate circular nature
- Stack keeps possible next greater elements
- First `1` â†’ next greater is `2`
- `2` â†’ no greater element â†’ `-1`
- Last `1` â†’ next greater is `2`

Final Output:
[2, -1, 2]

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public int[] nextGreaterElements(int[] nums) {
        Stack<Integer> stack = new Stack<>();
        int[] result = new int[nums.length];
        Arrays.fill(result, -1);

        for (int i = 2 * nums.length - 1; i >= 0; i--) {
            int idx = i % nums.length;

            while (!stack.isEmpty() && stack.peek() <= nums[idx]) {
                stack.pop();
            }

            if (i < nums.length) {
                result[i] = stack.isEmpty() ? -1 : stack.peek();
            }

            stack.push(nums[idx]);
        }
        return result;
    }
}
```

---

## ğŸ”¹ Time & Space Complexity

Time Complexity:
- O(n) â†’ each element pushed and popped at most once

Space Complexity:
- O(n) â†’ stack + result array

---

## ğŸ”¹ Patterns Learned

- Monotonic stack solves next greater problems
- Circular arrays can be handled using modulo
- Traverse from right to left for next greater
- Use second traversal only for stack preparation

---

## ğŸ”¹ Common Mistakes to Avoid

- Forgetting to simulate circular array
- Filling result during both passes
- Using indices instead of values incorrectly
- Traversing from left to right
