---
title: "LeetCode 84 â€“ Largest Rectangle in Histogram"
difficulty: Hard
pattern: Monotonic Stack
status: Understood
---

## ğŸ”¹ Problem Summary
Given an array `heights` representing bar heights of a histogram,  
find the **area of the largest rectangle** that can be formed using contiguous bars.

---

## ğŸ”¹ My First Thought (Initial Approach)
For every bar, expand left and right until a smaller bar is found and calculate area.

âŒ This brute force approach takes O(nÂ²) time.

---

## ğŸ”¹ Key Observation
- The width of a rectangle is limited by the **first smaller bar on the left and right**
- We need a way to quickly find these boundaries
- A **monotonic increasing stack** helps track indices of bars

---

## ğŸ”¹ Final Approach (Step-by-Step in English)

1. Use a stack that stores **indices of bars in increasing height order**.
2. Traverse the array from index `0` to `n` (inclusive):
   - Treat index `n` as a **dummy bar of height 0** to flush the stack.
3. For each index `i`:
   - Set `currHeight` as:
     - `heights[i]` if `i < n`
     - `0` if `i == n`
4. While stack is not empty and `currHeight < height at stack top`:
   - Pop the top index â†’ this bar is the **minimum height** of a rectangle.
   - Right boundary = current index `i`
   - Left boundary = new stack top (or `-1` if empty)
   - Width = `right - left - 1`
   - Area = `height Ã— width`
   - Update maximum area.
5. Push current index `i` into the stack.
6. Return the maximum area found.

---

## ğŸ”¹ Example Walkthrough

Input:
heights = [2,1,5,6,2,3]

Process:
- Stack keeps increasing heights
- When a smaller bar appears, calculate areas for taller bars
- Dummy `0` at the end forces remaining bars to be processed

Final Output:
10  
(Rectangle using heights 5 and 6)

---

## ğŸ”¹ Java Code (Final)
> âš ï¸ Code added after fully understanding the logic.

```java
class Solution {
    public int largestRectangleArea(int[] heights) {
        Stack<Integer> stack = new Stack<>();
        int maxArea = 0;

        for (int i = 0; i <= heights.length; i++) {
            int currheight = (i == heights.length) ? 0 : heights[i];

            while (!stack.isEmpty() && currheight < heights[stack.peek()]) {
                int height = heights[stack.pop()];
                int right = i;
                int left = stack.isEmpty() ? -1 : stack.peek();
                int width = right - left - 1;

                maxArea = Math.max(maxArea, height * width);
            }
            stack.push(i);
        }
        return maxArea;
    }
}
```

---

## ğŸ”¹ Time & Space Complexity

Time Complexity:
- O(n) â†’ each index pushed and popped once

Space Complexity:
- O(n) â†’ stack usage

---

## ğŸ”¹ Patterns Learned

- Monotonic stacks solve range-boundary problems
- Width is determined **after popping**
- Dummy element helps flush remaining stack
- Always store indices, not heights

---

## ğŸ”¹ Common Mistakes to Avoid

- Forgetting the dummy `0` height
- Using heights instead of indices in stack
- Miscalculating width (`right - left - 1`)
- Traversing only till `n - 1`
