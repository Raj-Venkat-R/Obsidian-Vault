---
title: Arrays â€“ Insertion, Deletion & Update
topic: Data Structures
subtopic: Arrays
order: 3
purpose: Understand Array Operations & Limitations
---

# Insertion, Deletion & Update in Arrays

Arrays allow **access and update easily**, but **insertion and deletion are costly**.  
This topic explains **why**.

---

## ðŸ”¹ Update in an Array

### What is Update?
**Update** means changing the value of an element at a specific index.

### Example
```java
arr[2] = 99;
```

### Diagram
```
Before â†’ | 10 | 20 | 30 | 40 |
Index  â†’   0    1    2    3

After  â†’ | 10 | 20 | 99 | 40 |
```

### Important Points
- No shifting required
- Direct access using index
- Very fast operation

ðŸ‘‰ Update is **cheap** in arrays.

---

## ðŸ”¹ Insertion in an Array

### Types of Insertion
1. Insert at the **end**
2. Insert at the **beginning**
3. Insert in the **middle**

---

### 1. Insertion at the End

#### Condition
- Array must have **free space**

### Example
```java
arr[size] = value;
size++;
```

### Diagram
```
Before â†’ | 10 | 20 | 30 | _  |
After  â†’ | 10 | 20 | 30 | 40 |
```

âœ… Fast  
âŒ Fails if array is full

---

### 2. Insertion at the Beginning

Steps:
1. Shift all elements **right**
2. Insert value at index `0`

### Diagram
```
Before â†’ | 10 | 20 | 30 |
Shift  â†’ | 10 | 10 | 20 | 30 |
Insert â†’ |  5 | 10 | 20 | 30 |
```

âŒ Costly due to shifting

---

### 3. Insertion in the Middle

Steps:
1. Shift elements to the right from insertion index
2. Insert new value

### Example: Insert `25` at index `2`

```
Before â†’ | 10 | 20 | 30 | 40 |
Shift  â†’ | 10 | 20 | 30 | 30 | 40 |
Insert â†’ | 10 | 20 | 25 | 30 | 40 |
```

âŒ Costly  
âŒ Requires shifting many elements

---

## ðŸ”¹ Deletion in an Array

### What is Deletion?
Removing an element and **maintaining order**.

---

### 1. Deletion from the End

Steps:
- Just reduce logical size

```java
size--;
```

```
Before â†’ | 10 | 20 | 30 |
After  â†’ | 10 | 20 | _  |
```

âœ… Fast  
(No shifting)

---

### 2. Deletion from the Beginning

Steps:
1. Remove element at index `0`
2. Shift all elements **left**

```
Before â†’ | 10 | 20 | 30 |
Shift  â†’ | 20 | 30 | _  |
```

âŒ Costly

---

### 3. Deletion from the Middle

Steps:
1. Remove element
2. Shift remaining elements left

Example: Delete index `1`

```
Before â†’ | 10 | 20 | 30 | 40 |
Shift  â†’ | 10 | 30 | 40 | _  |
```

âŒ Costly  
âŒ Shifting required

---

## ðŸ”¹ Why Insertion & Deletion are Slow

Because arrays use **contiguous memory**:
- Elements must remain side by side
- Any gap breaks memory order
- Shifting is unavoidable

This is the **biggest limitation of arrays**.

---

## ðŸ”¹ Logical Size vs Physical Size (Revisited)

- **Physical size** â†’ allocated memory
- **Logical size** â†’ number of used elements

Insertion & deletion mostly affect:
- **Logical size**

---

## ðŸ”¹ Time Cost Intuition

| Operation | Cost |
|--------|------|
| Update | Very fast |
| Insert at end | Fast (if space) |
| Insert at start | Slow |
| Insert in middle | Slow |
| Delete at end | Fast |
| Delete at start | Slow |
| Delete in middle | Slow |

---

## ðŸ”¹ Key Mental Model (VERY IMPORTANT)

> Arrays are **good at access & update**  
> Arrays are **bad at insertion & deletion**

This single rule explains:
- Why linked lists exist
- Why dynamic arrays resize
- Why shifting happens

---

## Topic Completed
âœ” Update  
âœ” Insertion (all cases)  
âœ” Deletion (all cases)  
âœ” Why shifting is required  


