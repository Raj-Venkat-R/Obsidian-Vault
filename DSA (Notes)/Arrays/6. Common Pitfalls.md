---
title: Arrays â€“ Common Pitfalls
topic: Data Structures
subtopic: Arrays
order: 5
purpose: Avoid Runtime Errors & Logic Bugs
---

# Common Pitfalls in Arrays

Most array errors are **not algorithmic** â€” they are **indexing and boundary mistakes**.  
Understanding these pitfalls saves hours of debugging.

---

## ðŸ”¹ 1. Off-by-One Error

### What is it?
Using an index that is **one position too early or too late**.

### Example (WRONG)
```java
for (int i = 0; i <= arr.length; i++) {
    System.out.println(arr[i]);
}
```

### Why it fails
- Last valid index = `arr.length - 1`
- `i == arr.length` â†’ âŒ invalid access

### Correct Way
```java
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```

---

## ðŸ”¹ 2. Accessing Out of Bounds

### What is it?
Trying to access an index that does not exist.

### Example
```java
arr[arr.length] = 10;
```

âŒ Causes:
```
ArrayIndexOutOfBoundsException
```

### Rule (MEMORIZE)
```
Valid index range â†’ 0 to length - 1
```

---

## ðŸ”¹ 3. Confusing Index with Value

### Example
```java
int index = arr[i];
arr[index] = 100;
```

âŒ Problem:
- `arr[i]` is a **value**, not an index
- Value may be larger than array size

Always ask:
> Is this variable an **index** or a **value**?

---

## ðŸ”¹ 4. Wrong Loop Direction While Shifting

### Insertion at Start (WRONG)
```java
for (int i = 0; i < size; i++) {
    arr[i + 1] = arr[i];
}
```

### What happens
```
| 10 | 20 | 30 |
â†’ | 10 | 10 | 10 | âŒ
```

### Correct Direction
```java
for (int i = size - 1; i >= 0; i--) {
    arr[i + 1] = arr[i];
}
```

---

## ðŸ”¹ 5. Modifying Array While Traversing

### Example
```java
for (int i = 0; i < size; i++) {
    if (arr[i] == 0) {
        delete(arr, i);
    }
}
```

âŒ Problem:
- Deletion shifts elements
- Next element is skipped

### Safe Approach
- Traverse carefully
- Or traverse **backwards**
- Or use extra space

---

## ðŸ”¹ 6. Using `length` Instead of Logical Size

### Example
```java
for (int i = 0; i < arr.length; i++) {
    System.out.println(arr[i]);
}
```

âŒ If array has unused slots, garbage or defaults appear.

### Correct Approach
```java
for (int i = 0; i < size; i++) {
    System.out.println(arr[i]);
}
```

---

## ðŸ”¹ 7. Assuming Array Grows Automatically

### Common Wrong Assumption
```java
n++;
arr[n] = 10;
```

âŒ Array size does NOT change.

### Truth
- Only logical size changes
- Physical size is fixed forever

---

## ðŸ”¹ 8. Forgetting Empty Array Case

### Example
```java
int max = arr[0];
```

âŒ If array is empty â†’ crash

### Always check
```java
if (size == 0) return;
```

---

## ðŸ”¹ 9. Overwriting Before Using Value

### Example
```java
arr[i] = arr[i + 1];
```

âŒ Original value lost forever

Use temp variable when needed.

---

## ðŸ”¹ 10. Mixing `<` and `<=` Without Thinking

### Dangerous Pattern
```java
i <= size - 1
```

Safer pattern:
```java
i < size
```

---

## ðŸ”¹ Mental Checklist Before Running Code

Ask yourself:
- Are indices inside bounds?
- Am I using physical size or logical size?
- Am I shifting in correct direction?
- Am I overwriting needed data?
- Will deletion affect traversal?

---

## ðŸ”¹ Golden Rule (REMEMBER THIS)

> **Most array bugs are boundary bugs**

Fix boundaries â†’ fix logic.

---

## Topic Completed
âœ” Off-by-one errors  
âœ” Bounds issues  
âœ” Shifting mistakes  
âœ” Traversal pitfalls  
