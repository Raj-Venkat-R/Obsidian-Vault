---
title: DSA Learning Roadmap (Concepts Only)
purpose: LeetCode Preparation
status: Ongoing
start_date: 2026-02-10
---
# DSA Study Order (Concept-First Roadmap)

> Goal: Master core concepts first â†’ apply them to LeetCode problems later

---

## ğŸŸ¢ PHASE 0: Absolute Foundations (Must Know)
- [x] What is DSA & why it matters
- [x] How computers store data (memory basics)
- [x] Time Complexity intuition (Big-O idea)
- [x] Space Complexity intuition
- [x] Iteration vs Recursion (high-level idea)

---

## ğŸŸ¢ PHASE 1: Arrays (THE BASE OF EVERYTHING)
- [x] What is an array (contiguous memory)
- [x] Indexing & traversal
- [x] Insertion, deletion, update
- [x] Fixed vs dynamic arrays
- [x] Common pitfalls (off-by-one, bounds)
- [x] Brute force thinking with arrays
- [x] Prefix sum concept
- [x] Difference between array & list (Java context)

---

## ğŸŸ¢ PHASE 2: Strings (Array of Characters)
- [ ] How strings are stored
- [ ] String immutability (important!)
- [ ] Character access & traversal
- [ ] Comparing strings
- [ ] Substrings & slicing concept
- [ ] Frequency counting idea
- [ ] Common string mistakes

---

## ğŸŸ¢ PHASE 3: Sorting Algorithms (FOUNDATIONAL)
- [ ] Why sorting helps problem solving
- [ ] Comparison vs non-comparison sorting (idea)
- [ ] Bubble / Selection / Insertion sort (intuition)
- [ ] Merge sort (divide & conquer idea)
- [ ] Quick sort (partition idea)
- [ ] Stability & in-place concept
- [ ] Java `Arrays.sort()` & `Collections.sort()`
- [ ] When NOT to sort

---

## ğŸŸ¢ PHASE 4: Searching Algorithms
- [ ] Linear search
- [ ] Binary search (revisit with sorted data)
- [ ] Binary search on answers
- [ ] Lower bound & upper bound concept
- [ ] When binary search fails

---

## ğŸŸ¢ PHASE 5: Two Pointers Technique
- [ ] Why two pointers work
- [ ] Same-direction pointers
- [ ] Opposite-direction pointers
- [ ] Two pointers + sorted arrays
- [ ] When NOT to use two pointers
- [ ] Array vs string use cases

---

## ğŸŸ¢ PHASE 6: Sliding Window Technique
- [ ] Fixed-size window concept
- [ ] Variable-size window concept
- [ ] Expandâ€“shrink logic
- [ ] Sliding window + frequency map
- [ ] Window vs two pointers confusion

---

## ğŸŸ¢ PHASE 7: Hashing / Frequency (CORE OPTIMIZATION TOOL)
- [ ] What is hashing (conceptual)
- [ ] HashMap / HashSet intuition
- [ ] Frequency array vs hashmap
- [ ] Hashing with strings
- [ ] Hashing with sliding window
- [ ] When hashing improves time complexity
- [ ] Space vs time trade-offs

---

## ğŸŸ¢ PHASE 8: 2D Arrays / Matrices
- [ ] What is a 2D array (array of arrays)
- [ ] Memory model in Java
- [ ] Rows vs columns
- [ ] Rectangular vs jagged arrays
- [ ] Declaration & initialization
- [ ] Row-wise traversal
- [ ] Column-wise traversal
- [ ] Boundary traversal
- [ ] Diagonal & anti-diagonal traversal
- [ ] Spiral traversal
- [ ] Brute force thinking in matrices
- [ ] Prefix sum in 2D
- [ ] Hashing with matrices
- [ ] Common 2D pitfalls

---

## ğŸŸ¢ PHASE 9: Recursion (Core Thinking Skill)
- [ ] What recursion really is
- [ ] Base case & recursive case
- [ ] Call stack visualization
- [ ] When recursion is bad
- [ ] Recursion vs iteration

---

## ğŸŸ¢ PHASE 10: Backtracking (State Space Search)
> Recursion + decision making

- [ ] What backtracking is
- [ ] Choose â†’ Explore â†’ Un-choose pattern
- [ ] Decision tree intuition
- [ ] Constraints pruning
- [ ] Backtracking vs brute force
- [ ] When to use backtracking

---

## ğŸŸ¢ PHASE 11: Linked List
- [ ] Node & pointer concept
- [ ] Singly vs doubly linked list
- [ ] Traversal logic
- [ ] Reversal intuition
- [ ] Fast & slow pointer idea

---

## ğŸŸ¢ PHASE 12: Stack (LIFO Thinking)
- [ ] Stack operations
- [ ] Stack in memory (call stack link)
- [ ] Monotonic stack idea
- [ ] When stack simplifies problems

---

## ğŸŸ¢ PHASE 13: Queue (FIFO Thinking)
- [ ] Queue operations
- [ ] Circular queue idea
- [ ] BFS intuition preview
- [ ] Queue vs stack comparison

---
## ğŸŸ¢ PHASE 14: Trees (General)
- [ ] Tree terminology
- [ ] Binary tree basics
- [ ] DFS vs BFS
- [ ] Recursion in trees
- [ ] Tree traversal patterns

---
## ğŸŸ¢ PHASE 15: Binary Search Tree (BST)
- [ ] BST property
- [ ] Why BST is powerful
- [ ] Inorder traversal meaning
- [ ] Common BST pitfalls

---

## ğŸŸ¢ PHASE 16: Heap / Priority Queue
- [ ] What heap guarantees (and what it doesnâ€™t)
- [ ] Min heap vs max heap
- [ ] Heap vs sorted array
- [ ] Top-K problems intuition

---

## ğŸŸ¢ PHASE 17: Graphs
- [ ] Graph terminology
- [ ] Adjacency list vs matrix
- [ ] BFS vs DFS
- [ ] Cycle detection intuition
- [ ] Connected components
- [ ] Topological sorting idea

---

## ğŸŸ¢ PHASE 18: Segment Tree (ADVANCED RANGE QUERIES)
- [ ] Why segment trees exist
- [ ] Range query concept
- [ ] Build segment tree intuition
- [ ] Query operation (range)
- [ ] Update operation
- [ ] Segment tree vs prefix sum
- [ ] When segment tree is overkill

---

## ğŸŸ¢ PHASE 19: Greedy Thinking
- [ ] What greedy really means
- [ ] Local vs global optimum
- [ ] Greedy proof intuition
- [ ] When greedy fails

---

## ğŸŸ¢ PHASE 20: Dynamic Programming (LAST & HEAVY)
- [ ] Why DP exists
- [ ] Overlapping subproblems
- [ ] Optimal substructure
- [ ] Memoization vs tabulation
- [ ] 1D DP intuition
- [ ] 2D DP intuition

---

## ğŸŸ¢ PHASE 21: Bit Manipulation (Optional but Powerful)
- [ ] Binary representation
- [ ] AND, OR, XOR meaning
- [ ] Bit masking idea
- [ ] Why XOR is special

---

## ğŸ Final Goal
- [ ] Identify pattern from problem
- [ ] Choose correct data structure
- [ ] Optimize from brute force
- [ ] Explain solution in plain English
